
local cmd = {}

function command_get_list()
	return cmd
end

function command_get_count()
	local count = 0
	for k,v in pairs(cmd) do
		count = count + 1
	end
	return count
end

function command_get_count()
	local count = 0
	for k,v in pairs(cmd) do
		count = count + 1
	end
	return count
end

function command_exists(name)
	return cmd[name] ~= nil
end

function command_give(name,...)
	return cmd[name](name,...)
end


function trim(s)
	return string.gsub(s, "^%s*(.-)%s*$", "%1")
end

function first_word(caller,txt,owner,msg)
	local wrd = ""
	local _strt, _end = string.find(txt,".%S+")
	if (_strt and _end) then
		wrd = string.sub(txt,_strt, _end)
		wrd = string.lower(wrd)
	else
		owner:SendOutput("For usage type %s help",caller)
		return
	end

	if (string.find(wrd,"help")) then
		owner:SendOutput("%s %s",caller,msg)
		return
	end
	return wrd
end

-- HELP
function cmd.help(me,txt,owner,p)
	local wrd = ""
	local _strt, _end = string.find(txt,"%d+")
	if (_strt and _end) then
		wrd = string.sub(txt,_strt, _end)
		wrd = string.lower(wrd)
	end

	local page = wrd ~= "" and tonumber(wrd) or 1
	local sz = owner.console_size

	if not (sz) or (sz == 0) then return "help := error" end

	local list_sz = command_get_count()
	local page_count = math.ceil(list_sz/sz)

	if (page > page_count) then
		return "help:= Invaild page"
	end

	owner:SendOutput("help := Command List [%s of %s]",page,page_count)

	local commands = command_get_list()
	local a = {}
    for n in pairs(commands) do table.insert(a, n) end
    table.sort(a)
	for i=1,sz do
		local ind = (page*sz - sz) + i
		local k = ind > 0 and a[ind]
		local out = " "

		if (k == "help") then
			out = ""
		end

		if (k and commands[k] and k ~= "help") then
			out = command_give(k,"help",owner,p)
		end
		owner:SendOutput(out)
	end
end

-- ECHO
function cmd.echo(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"<message>")
	if not (wrd) then return end
	return txt
end

-- SPAWN
--[[
example usage:

spawn s:stalker id:%s amt:5 $db.actor:id()     -- Spawns 5 stalkers at actor's position

spawn s:wpn_pm id:5424 						   -- Spawns Pistol on ID's position

spawn s:wpn_pm id:$db.actor:id()$

spawn s:wpn_pm pos:244,355,123 lvid:11344 gvid:12  -- Spawns pistol at exact location

--]]
function cmd.spawn(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"s:<section> id:<number> amt:<number> [ pos:<x,y,z> lvid:<x,y,z> gvid:<x,y,z> ]")
	if not (wrd) then return end

	if (wrd == "reset") then
		owner.spawn_pos = nil
		owner.spawn_lvid = nil
		owner.spawn_gvid = nil
		return "spawn:= position reset to always actor"
	end

	local sec
	if (string.find(txt,"s:")) then
		for s in string.gmatch(txt,"s:(.%S+)") do
			sec = s
		end
	end


	if not (sec) or not (system_ini():section_exist(sec)) then
		return "spawn:= Section %s does not exist.",sec
	end

	local pos,lvid,gvid,id

	if (string.find(txt,"id:")) then
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end

		local obj = level.object_by_id(id)
		if (obj) then
			pos = obj:position()
			lvid = obj:level_vertex_id()
			gvid = obj:game_vertex_id()
		end
	else
		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
				local p = alun_utils.str_explode(s,",")
				pos = vector():set(tonumber(p[1]),tonumber(p[2]),tonumber(p[3]))
			end

			if (string.find(txt,"lvid:")) then
				for s in string.gmatch(txt,"lvid:(%w+)") do
					lvid = tonumber(s)
				end
			else
				return "spawn:= Must specify level_vertex_id along with position."
			end

			if (string.find(txt,"gvid:")) then
				for s in string.gmatch(txt,"gvid:(%w+)") do
					gvid = tonumber(s)
				end
			else
				return "spawn:= Must specify game_vertex_id along with position."
			end
		else
			return "spawn:= Must specify id or position. Type spawn help"
		end
	end

	local amt = 1
	if (string.find(txt,"amt:")) then
		for s in string.gmatch(txt,"amt:(%d+)") do
			amt = tonumber(s)
		end
	end

	if (pos) and (lvid) and (gvid) then
		for i=1,amt do
			local obj = alife():create(sec,pos,lvid,gvid,id)
		end

		if (amt > 1) then
			return "Spawn:= Objects created"
		end

		if not (obj) then
			return "spawn:= Object nil"
		end
		return "spawn:= Object %s created as ID %s.",obj:name(),obj.id
	end

	local p = string.format("%0.2f,%0.2f,%0.2f",pos.x,pos.y,pos.z)
	return "spawn:= Error pos=%s lvid=%s gvid=%s",p,lvid,gvid
end

-- SURGE
function cmd.surge(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"[start|stop]")
	if not (wrd) then return end

	local sm = surge_manager.get_surge_manager()
	if not (sm) then return "No surge manager!" end

	if (wrd == "start") then
		sm:start(true)
		return "surge:= started"
	elseif (wrd == "stop") then
		sm:end_surge(true)
		return "surge:= ended"
	else
		return "surge:= wrong argument passed."
	end
end

-- Find
function cmd.find(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"<name>")
	if not (wrd) then return end

	if (p[1]) then
		owner:FindNearest(p[1])
	else
		owner:FindNearest(wrd)
	end
end

-- Execute
function cmd.execute(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"<string>")
	if not (wrd) then return end

	local loadstring = alun_utils.memoize(loadstring)
	local f,err = loadstring(wrd)
	if (f) then
		f()
	else
		return err
	end
end

-- Alife

function cmd.alife(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"{switch}")
	if not (wrd) then return end

	if (string.find(wrd,"switch")) then
		--[[
		if (string.find(txt,"set:")) then
			local d
			for s in string.gmatch(txt,"set:(%d+)") do
				d = tonumber(s)
			end
			if not (d) then
				return "alife := Invalid value for switch distance set:%s",d
			end
			local old = alife():switch_distance()
			alife():switch_distance(d)
			return "alife := switch distance changed from %s to %s",old,d
		elseif (string.find(txt,"get")) then
			local sd = alife():switch_distance()
			return "alife := switch distance is %s",sd
		else
			return "alife switch [get|set:<value>]"
		end
		--]]
		local sd = alife():switch_distance()
		return "alife:= switch distance is %s",sd
	end
end

-- Clear
function cmd.clear(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"(Clears console)")
	if (string.find(txt,"help")) then
		return
	end

	for i=1,owner.console_size do
		owner.txt_console[i]:SetText("")
	end
end

-- Squad
function cmd.squad(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"{assign}")
	if not (wrd) then return end

	if (string.find(wrd,"assign")) then
		local id,squad,a_id,target
		if (string.find(txt,"id:")) then
			for s in string.gmatch(txt,"id:(%d+)") do
				id = tonumber(s)
			end

			squad = alife():object(id)
			if not (squad) then
				return "squad:= improper id used. id:%s",id
			end
		end

		if (string.find(txt,"target:")) then
			for s in string.gmatch(txt,"target:(%d+)") do
				a_id = tonumber(s)
			end

			target = alife():object(a_id)
			if not (target) then
				return "squad:= assign target does not exist. assign:%s",a_id
			end
		end

		if (squad and target) then
			alun_utils.assign_squad_to_smart(squad.id,target.id)
			return "squad := %s assigned to %s.",squad:name(),target:name()
		end
	end

	return "squad:= squad assign id:<id> target:<id>"
end

-- Console
function cmd.console(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"{relay}")
	if not (wrd) then return end

	if (string.find(wrd,"relay")) then
		if (owner.console_relay) then
			owner.console_relay = false
			return "Toggled off relay to game console"
		else
			owner.console_relay = true
		end
		return "Toggled on relay to game console"
	end
end

-- Teleport
function cmd.teleport(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"who:<id> [ to:<id> | pos:<x,y,z> | $code$ | cam ]")
	if not (wrd) then return end

	local who,to_pos

	if (string.find(txt,"who:")) then
		local who_id
		for s in string.gmatch(txt,"who:(%w+)") do
			who_id = tonumber(s)
		end

		who = alife():object(who_id)
		if not (who) then
			return "teleport := Wrong arugument given or object doesn't exist. who:<%s>",who_id
		end
	end

	if (string.find(txt,"to:")) then
		local id
		for s in string.gmatch(txt,"to:(%w+)") do
			id = tonumber(s)
		end

		local obj = alife():object(id)
		if not (obj) then
			return "teleport := Wrong arugment given or object doesn't exist. id:%s",id
		end

		to_pos = obj.position
	else
		local pos = p[1]

		if (string.find(txt,"cam")) then
			pos = xrs_debug_tools.LastCameraPos
		end

		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:([-]?%d+[.]?%d*,[-]?%d+[.]?%d*,[-]?%d+[.]?%d*)") do
				local t = alun_utils.str_explode(s,",")
				pos = vector():set(tonumber(t[1]),tonumber(t[2]),tonumber(t[3]))
			end
		end

		if not (pos) then
			return "teleport := wrong format for position. pos:%s must be pos:x,y,z"
		end

		to_pos = pos
	end

	if (who and to_pos) then
		local object = level.object_by_id(who.id)
		if (db.actor:id() == who.id) then
			object:set_actor_position(to_pos)
		else
			object:set_npc_position(to_pos)
		end
		local pos = string.format("%0.3f, %0.3f, %0.3f",to_pos.x,to_pos.y,to_pos.z)
		return "teleport:= %s teleported to pos:%s",object.character_name and object:character_name() or object:name(),pos
	end
end

-- Wound
function cmd.wound(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"id:<number>")
	if not (wrd) then return end

	local id
	local vo
	if (string.find(txt,"id:")) then
		for s in string.gmatch(txt,"id:(%d+)") do
			id = tonumber(s)
		end

		vo = level.object_by_id(id)
		if not (vo) then
			return "wound:= Wrong arugument given or object doesn't exist. id:<%s>",id
		end
	end

	if (vo) then
		local h = hit()
		h.type = hit.fire_wound
		h.power = (1 - vo.health) + vo.health - 0.09
		h.impulse = 0.0
		h.direction = vector():set(0,0,1)
		h.draftsman = vo
		vo:hit(h)
		return "wound:= %s has been hit for %s.",vo:name(),h.power
	end
end

local var_list = { ["actor"] = db.actor}
function get_var_list()
	return var_list
end

-- Var
function cmd.var(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"<name> $code$")
	if not (wrd) then return end

	if (wrd == "clear") then
		for k,v in pairs(var_list) do
			var_list[k] = nil
		end
		return "var:= All vars cleared"
	end

	if (wrd == "list") then
		local _strt, _end = string.find(txt,"list")
		if (_strt and _end) then
			wrd = string.sub(txt,_strt, _end)
			wrd = string.lower(wrd)
		end

		local page = wrd and wrd ~= "" and tonumber(wrd) or 1
		local sz = owner.console_size

		if not (sz) or (sz == 0) then return "var:= error" end

		local list_sz = 0
		local list_count = function()
			for k,v in pairs(var_list) do
				list_sz = list_sz + 1
			end
		end

		list_count()
		local page_count = math.ceil(list_sz/sz)

		if (page > page_count) then
			return "var:= Invaild page"
		end

		owner:SendOutput("var:= Variable List [%s of %s]",page,page_count)

		local a = {}
		for n in pairs(var_list) do table.insert(a, n) end
		table.sort(a)
		for i=1,sz do
			local ind = (page*sz - sz) + i
			local k = ind > 0 and a[ind]
			local out = " "

			if (k) then
				local v = var_list[k]
				if ( type(v) == "userdata" ) then
					out = string.format("%s = %s",k,"userdata")
					if (v.name and type(v.name) == "function" ) then
						out = string.format("%s = userdata [%s]",k,v:name())
					elseif (v.position) then
						local pos
						if (type(v.position) == "function") then
							pos = v:position()
							out = string.format("%s = userdata [%s,%s,%s]",k,pos.x,pos.y,pos.z)
						else
							pos = v.position
							out = string.format("%s = userdata [%s,%s,%s]",k,pos.x,pos.y,pos.z)
						end
					elseif (v.x and v.y and v.z) then
						out = string.format("%s = userdata [%s,%s,%s]",k,v.x,v.y,v.z)
					end
				elseif ( type(v) == "number" or type(v) == "string" or type(v) == "table" or type(v) == "function") then
					out = string.format("%s = %s",k,v)
				end
			end
			owner:SendOutput(out)
		end
		return
	end

	if (wrd) then
		var_list[wrd] = p[1]
		return "var:= variable %s set.",wrd
	end
end

-- Vector
function cmd.vector(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"{add|sub}")
	if not (wrd) then return end

	if (wrd == "add") then
		local inc = {}

		inc.v = match_or_var(txt,"v:",".%S+",p[1])

		if not (inc.v) then
			return "vector:= Wrong arugument given to inc -> v:"
		end

		inc.x = tonumber( match_or_var(txt,"x:",".%S+",p[2]) ) or 0
		inc.y = tonumber( match_or_var(txt,"y:",".%S+",p[3]) ) or 0
		inc.z = tonumber( match_or_var(txt,"z:",".%S+",p[4]) ) or 0

		inc.v = inc.v:add( vector():set(inc.x,inc.y,inc.z) )
		return "vector:= vector updated to vector"
	end

	if (wrd == "sub") then
		local v = {}

		v[1] = match_or_var(txt,"1:",".%S+",p[1])
		v[2] = match_or_var(txt,"2:",".%S+",p[2])

		if (v[1] and v[2]) then
			local p1,p2
			if ( type(v[1]) == "string" ) then
				p1 = level.object_by_id( tonumber(p1) ):position()
			else
				p1 = v[1]
			end

			if ( type(v[2]) == "string" ) then
				p2 = level.object_by_id( tonumber(p2) ):position()
			else
				p2 = v[2]
			end

			local pr = p1 and p2 and p1:sub(p2)
			if (pr) then
				return "vector:= %s,%s,%s",pr.x,pr.y,pr.z
			end
		end
		return "vector:= Wrong arugument given or object(s) do not exist."
	end
end

--level.object_by_id():bone_position("bip01_l_hand")
--level.object_by_id():bone_position("bip01_root")

-- Offset
function cmd.offset(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"{get}")
	if not (wrd) then return end

	if (wrd == "get") then

		if (string.find(txt,"help")) then
			return "offset get [ 1:<id> 2:<id> | 1:<$var$> 2:<$var$> ]"
		end

		local v = {}
		v[1] = match_or_var(txt,"1:",".%S+",p[1])
		v[2] = match_or_var(txt,"2:",".%S+",p[2])

		if (v[1] and v[2]) then
			local p1,p2
			if ( type(v[1]) == "string" ) then
				p1 = level.object_by_id( tonumber(p1) )
			else
				p1 = v[1]
			end

			if ( type(v[2]) == "string" ) then
				p2 = level.object_by_id( tonumber(p2) )
			else
				p2 = v[2]
			end

			local pr = get_position_offset(v[1],v[2])
			if (pr) then
				return "offset:= position(%s,%s,%s)",pr.x,pr.y,pr.z
			end
		end
	end

end

function get_position_offset(npc,o)
	local sec = o:section()
	local attach_bone_name = alun_utils.read_from_ini(nil,sec,"attach_bone_name","string",nil)
	if not (attach_bone_name) then
		return
	end
	local pos1 = npc:bone_position(attach_bone_name)
	local pos2 = o:center()
	return pos1:sub(pos2)
end

function match_or_var(txt,token,pat,var)
	if (var and var_list[var]) then
		return var_list[var]
	end

	if (string.find(txt,token)) then
		local v
		for s in string.gmatch(txt,token.."("..pat..")") do
			v = s
		end
		return v
	end
end

-- Hud
function cmd.hud(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		xrs_debug_tools.set_draw_debug_hud(true)
		return "hud:= debug hud enabled"
	end

	if (wrd == "off") then
		xrs_debug_tools.set_draw_debug_hud(false)
		return "hud:= debug hud disabled"
	end

	return "hud:= type hud help for list of sub commands"
end

-- God
function cmd.god(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		xrs_debug_tools.debug_god = true
		return "god:= invincibility enabled"
	end

	if (wrd == "off") then
		xrs_debug_tools.debug_god = nil
		return "god:= invincibility disabled"
	end

	return "god:= type god help for list of sub commands"
end

function cmd.crow(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"[on|off]")
	if not (wrd) then return end

	if (wrd == "on") then
		local se_crow = alun_utils.nearest_object("m_crow")
		xrs_debug_tools.crow_fun = se_crow.id
		return "crow:= enabled"
	end

	if (wrd == "off") then
		xrs_debug_tools.crow_fun = nil
		return "crow:= disabled"
	end

	return "crow:= type crow help for list of sub commands"
end

local heli_id
function cmd.heli(me,txt,owner,p)
	local wrd = first_word(me,txt,owner,"[spawn|move]")
	if not (wrd) then return end

	if (wrd == "spawn") then
		local se_heli = alun_utils.spawn_heli()
		if (se_heli) then
			heli_id = se_heli.id
			return "heli:= Spawned at actor position"
		end
		return "heli:= Spawning failed"
	end

	if (wrd == "move") then
		local str
		if (string.find(txt,"pos:")) then
			for s in string.gmatch(txt,"pos:(.%S+)") do
				str = s
			end
		end

		if (str and str ~= "") then
			str = str_explode(str,",")
			str.x = tonumber(str[1])
			str.y = tonumber(str[2])
			str.z = tonumber(str[3])
		end

		local obj = level.object_by_id(heli_id)
		local heli = obj and obj:get_helicopter()
		if (heli) then
			local pos = str or db.actor:position()
			heli:SetDestPosition(vector():set(pos.x,pos.y,pos.z))
			return "heli:= destination set to actor position"
		end
		return "heli:= move failed"
	end

	if (wrd == "attack") then




	end
	return "heli:= type heli help for list of sub commands"
end

function cmd.section_to_class(me,txt,owner,p)
-- Credits: Barin
	local m_classes =
	{
		["O_ACTOR"] = "cse_alife_creature_actor", -- actor (SOC)
		["S_ACTOR"] = "se_actor", -- actor (CS, COP)

		["AI_STL_S"] = "se_stalker", -- stalker (SOC, CS, COP)
		["AI_STL"] = "se_stalker", -- m_izgoy (SOC)
		["AI_TRD_S"] = "cse_alife_trader", -- m_trader (SOC, CS); m_lesnik (CS)

		["SM_BLOOD"] = "se_monster", -- bloodsucker (SOC, CS, COP)
		["SM_BOARW"] = "se_monster", -- boar (SOC, CS, COP)
		["SM_BURER"] = "se_monster", -- burer (SOC, CS, COP)
		["SM_CAT_S"] = "se_monster", -- cat (SOC, CS)
		["SM_CHIMS"] = "se_monster", -- chimera (SOC, CS, COP)
		["SM_CONTR"] = "se_monster", -- controller (SOC, CS, COP)
		["AI_CROW"] = "cse_alife_creature_abstract", --"cse_alife_creature_crow", -- crow (SOC, CS, COP)
		["SM_DOG_S"] = "se_monster", -- dog (SOC, CS, COP)
		["SM_FLESH"] = "se_monster", -- flesh (SOC, CS, COP)
		["SM_IZLOM"] = "se_monster", -- izlom (SOC, CS)
		["SM_GIANT"] = "se_monster", -- pseudogigant (SOC, CS, COP)
		["AI_PHANT"] = "cse_alife_creature_abstract", --"cse_alife_creature_phantom", -- phantom (SOC, CS, COP)
		["SM_POLTR"] = "se_monster", -- poltergeist (SOC, CS, COP)
		["SM_P_DOG"] = "se_monster", -- pseudodog (SOC, CS, COP)
		["SM_DOG_P"] = "se_monster", -- psy dog (SOC, CS, COP)
		["SM_DOG_F"] = "se_monster", -- psy dog phantom (SOC, CS, COP)
		["AI_RAT"] = "se_monster", -- rat (SOC, CS)
		["SM_SNORK"] = "se_monster", -- snork (SOC, CS, COP)
		["SM_TUSHK"] = "se_monster", -- tushkano (SOC, CS, COP)
		["SM_ZOMBI"] = "se_monster", -- zombie (SOC, CS)

		["C_HLCP_S"] = "cse_alife_helicopter", -- helicopter (SOC, CS, COP)
		["SCRPTCAR"] = "cse_alife_car", -- m_car (SOC, CS, COP)

		["ARTEFACT"] = "cse_alife_item", --"cse_alife_item_artefact", -- artefact (SOC, CS, COP)
		["SCRPTART"] = "cse_alife_item", --"cse_alife_item_artefact", -- artefact (SOC, CS, COP)

		["AI_GRAPH"] = "cse_alife_graph_point", -- graph_point (SOC, CS, COP)

		["ON_OFF_G"] = "cse_alife_online_offline_group", -- online_offline_group (SOC)
		["ON_OFF_S"] = "cse_alife_online_offline_group", -- online_offline_group (COP)

		["LVL_CHNG"] = "se_level_changer", -- level_changer (SOC, CS, COP)
		["SCRIPTZN"] = "cse_alife_space_restrictor", -- script_zone (SOC, CS, COP); sim_faction (COP)
		["SFACTION"] = "se_sim_faction", -- sim_faction (CS)
		["Z_TEAMBS"] = "cse_alife_team_base_zone", -- zone_team_base (SOC, CS, COP)
		["SPC_RS_S"] = "cse_alife_space_restrictor", -- space_restrictor (SOC, CS, COP); anomal_zone (CS, COP); camp_zone (COP)
		["SMRT_C_S"] = "se_smart_cover", -- smart_cover (CS, COP)
		["SMRTTRRN"] = "se_smart_terrain", -- smart_terrain (SOC, CS, COP)
		["RE_SPAWN"] = "se_respawn", -- respawn (SOC, CS)

		["II_ATTCH"] = "cse_alife_item", -- attachable_item (SOC, CS, COP)
		["II_BTTCH"] = "cse_alife_item", -- new_attachable_item (SOC, CS, COP)

		["II_DOC"] = "cse_alife_item_document", -- document (SOC, CS, COP)

		["O_HLAMP"] = "cse_alife_object_hanging_lamp", -- lights_hanging_lamp (SOC, CS); lights_signal_light (CS)
		["SO_HLAMP"] = "cse_alife_object_hanging_lamp", -- lights_hanging_lamp, lights_signal_light (COP)
		["O_SEARCH"] = "cse_alife_object_projector", -- search_light (SOC, CS, COP)
		["TORCH_S"] = "cse_alife_item_torch", -- device_torch (SOC, CS, COP)

		["O_BRKBL"] = "cse_alife_object_breakable", -- breakable_object (SOC, CS, COP)
		["O_CLMBL"] = "cse_alife_object_climable", -- climable_object (SOC, CS, COP)

		["O_PHYS_S"] = "cse_alife_object_physic", -- physic_object (SOC, CS, COP)
		["O_DSTR_S"] = "cse_alife_object_physic", -- physic_destroyable_object, physic_door (COP)
		["P_DSTRBL"] = "cse_alife_object_physic", -- physic_destroyable_object (SOC, CS)
		["P_SKELET"] = "cse_alife_ph_skeleton_object", -- ph_skeleton_object (SOC, CS, COP)

		["O_INVBOX"] = "cse_alife_inventory_box", -- inventory_box (SOC, CS)
		["S_INVBOX"] = "cse_alife_inventory_box", -- inventory_box (COP)

		["D_SIMDET"] = "cse_alife_item", --"cse_alife_item_detector", -- detector_simple (SOC, CS); detector_advances, detector_elite (SOC)
		["D_ADVANC"] = "cse_alife_item", --"cse_alife_item_detector", -- detector_advanced (CS)
		["D_ELITE"] = "cse_alife_item", --"cse_alife_item_detector", -- detector_elite (CS)
		["DET_SIMP"] = "cse_alife_item", --"cse_alife_item_detector", -- detector_simple (COP)
		["DET_ADVA"] = "cse_alife_item", --"cse_alife_item_detector", -- detector_advanced (COP)
		["DET_ELIT"] = "cse_alife_item", --"cse_alife_item_detector", -- detector_elite (COP)
		["DET_SCIE"] = "cse_alife_item", --"cse_alife_item_detector", -- detector_scientific (COP)

		["E_STLK"] = "cse_alife_item_custom_outfit", -- outfit (SOC, CS, COP)
		["EQU_MLTR"] = "cse_alife_item_custom_outfit", -- military_stalker_outfit, military_commander_outfit (SOC)
		["E_HLMET"] = "cse_alife_item_helmet", -- helmet (COP)

		["II_BANDG"] = "cse_alife_item", -- bandage (SOC, CS)
		["II_MEDKI"] = "cse_alife_item", -- meds (SOC, CS)
		["II_ANTIR"] = "cse_alife_item", -- antirad (SOC, CS)
		["II_BOTTL"] = "cse_alife_item", -- drink (SOC, CS)
		["II_FOOD"] = "cse_alife_item", -- edibles (SOC, CS)
		["S_FOOD"] = "cse_alife_item", -- edibles/meds (COP)

		["S_PDA"] = "cse_alife_item_pda", -- device_pda (COP)
		["D_PDA"] = "cse_alife_item_pda", -- device_pda (SOC, CS); dev_flash_1, dev_flash_2 (CS, COP)

		["II_BOLT"] = "cse_alife_item", --"cse_alife_item_bolt", -- bolt (SOC, CS, COP)

		["WP_KNIFE"] = "cse_alife_item_weapon", -- wpn_knife (SOC, CS, COP)

		["WP_BINOC"] = "cse_alife_item_weapon_magazined", -- wpn_binoc (SOC, CS, COP)
		["WP_RPG7"] = "cse_alife_item_weapon_magazined", -- wpn_rpg7 (SOC, CS, COP)
		["WP_HPSA"] = "cse_alife_item_weapon_magazined", -- wpn_hpsa (SOC, CS, COP)
		["WP_VAL"] = "cse_alife_item_weapon_magazined", -- wpn_val (SOC, CS, COP)
		["WP_SVU"] = "cse_alife_item_weapon_magazined", -- wpn_svu (SOC, CS, COP)
		["WP_SVD"] = "cse_alife_item_weapon_magazined", -- wpn_gauss, wpn_svd (SOC, CS, COP)

		["W_MOUNTD"] = "cse_alife_mounted_weapon", -- mounted_weapon (SOC, CS, COP)
		["W_STMGUN"] = "cse_alife_mounted_weapon", -- stationary_mgun (SOC, CS, COP)

		["II_EXPLO"] = "cse_alife_item", --"cse_alife_item_explosive", -- explosives (SOC, CS)
		["S_EXPLO"] = "cse_alife_item", --"cse_alife_item_explosive", -- explosives (COP)

		["WP_BM16"] = "cse_alife_item_weapon_shotgun", -- wpn_bm16, wpn_toz34 (SOC, CS, COP)
		["WP_ASHTG"] = "cse_alife_item_weapon_shotgun", -- wpn_protecta, wpn_spas12, wpn_wincheaster1300 (COP)
		["WP_SHOTG"] = "cse_alife_item_weapon_shotgun", -- wpn_spas12, wpn_wincheaster1300 (SOC, CS)
		["WP_RG6"] = "cse_alife_item_weapon_shotgun", -- wpn_rg-6 (SOC, CS, COP)

		["AMMO"] = "cse_alife_item_ammo", -- ammo (SOC, CS)
		["AMMO_S"] = "cse_alife_item_ammo", -- ammo (COP)
		["A_OG7B"] = "cse_alife_item_ammo", -- ammo_og-7b (SOC, CS)
		["S_OG7B"] = "cse_alife_item_ammo", -- ammo_og-7b (COP)
		["A_VOG25"] = "cse_alife_item_ammo", -- ammo_vog-25, ammo_vog-25p (SOC, CS)
		["S_VOG25"] = "cse_alife_item_ammo", -- ammo_vog-25 (COP)
		["A_M209"] = "cse_alife_item_ammo", -- ammo_m209 (SOC, CS)
		["S_M209"] = "cse_alife_item_ammo", -- ammo_m209 (COP)

		["G_F1"] = "cse_alife_item", --"cse_alife_item_grenade", -- grenade_f1, grenade_gd-05 (SOC, CS)
		["G_F1_S"] = "cse_alife_item", --"cse_alife_item_grenade", -- grenade_f1, grenade_gd-05 (COP)
		["G_RGD5"] = "cse_alife_item", --"cse_alife_item_grenade", -- grenade_rgd5 (SOC,CS)
		["G_RGD5_S"] = "cse_alife_item", --"cse_alife_item_grenade", -- grenade_rgd5 (COP)

		["WP_SCOPE"] = "cse_alife_item", -- wpn_addon_scope, wpn_addon_scope_susat (SOC, CS, COP)
		["W_SILENC"] = "cse_alife_item", -- wpn_addon_silencer (SOC, CS)
		["WP_SILEN"] = "cse_alife_item", -- wpn_addon_silencer (COP)
		["W_GLAUNC"] = "cse_alife_item", -- wpn_addon_grenade_launcher, wpn_addon_grenade_launcher_m203 (SOC, CS)
		["WP_GLAUN"] = "cse_alife_item", -- wpn_addon_grenade_launcher, wpn_addon_grenade_launcher_m203 (COP)

		["ZS_MBALD"] = "se_zone_anom", -- buzz, zharka_static, witches_galantine, mosquito_bald (SOC, CS, COP); zone_mine_* (CS, COP)
		["ZS_GALAN"] = "se_zone_anom", -- zone_gravi_zone (SOC, CS, COP)
		["ZS_MINCE"] = "se_zone_anom", -- zone_mincer (SOC, CS, COP)
		["ZS_RADIO"] = "se_zone_anom", -- zone_field_* (COP)
		["ZS_TORRD"] = "se_zone_torrid", -- fireball_zone, fireball_electric_zone, fireball_acidic_zone (COP)
		["ZS_BFUZZ"] = "se_zone_visual", -- zone_burning_fuzz (SOC, CS, COP)

		["Z_MBALD"] = "cse_alife_anomalous_zone", -- zone_teleport, zone_mine_field (SOC, CS, COP)
		["Z_RADIO"] = "cse_alife_anomalous_zone", -- zone_radioactive (SOC, CS, COP); zone_field_* (CS)
		["Z_ZONE"] = "cse_alife_anomalous_zone", -- zone_teleport_monolith (SOC, CS)
		["Z_CFIRE"] = "cse_alife_anomalous_zone", -- campfire (CS, COP)
		["Z_NOGRAV"] = "cse_alife_anomalous_zone", -- zone_no_gravity (SOC, CS, COP)

		["Z_TORRID"] = "cse_alife_torrid_zone", -- torrid_zone, fireball_zone (SOC)
		["Z_RUSTYH"] = "cse_alife_zone_visual", -- zone_rusty_hair (SOC, CS)
		["Z_AMEBA"] = "cse_alife_zone_visual", -- zone_ameba (SOC, CS)
	}
	local function write_file(text,...)
		if not text then return end
		local debug_file = io.open("section_to_class.txt","a+")

		if ( debug_file == nil ) then
			return
		end

		local i = 0
		local p = {...}
		local function sr(a)
			i = i + 1
			return tostring(p[i])
		end
		local output = string.gsub(text,"%%s",sr)

		debug_file:write(output.."\n")

		debug_file:close()
	end


	if not (se_item.registered_items) then
		return "section_to_class:= se_item.registered_items is nil"
	end
	if not (se_stalker.registered_stalkers) then
		return "section_to_class:= se_item.registered_items is nil"
	end

	local class,m_class,tab
	for sec,ct in pairs(se_item.registered_items) do
		class = alun_utils.read_from_ini(nil,sec,"class","string",nil)
		m_class = class and m_classes[class]

		if (string.find(sec,"%.") or string.find(sec,"-")) then
			sec = "'"..sec.."'"
		end
		tab = 7-string.len(sec)/8
		for i=1,tab do
			sec = sec .. "\t"
		end
		if (m_class) then
			write_file("%s => '%s',",sec,m_class)
		end
	end

	for sec,ct in pairs(se_stalker.registered_stalkers) do
		class = alun_utils.read_from_ini(nil,sec,"class","string",nil)
		m_class = class and m_classes[class]

		if (string.find(sec,"%.") or string.find(sec,"-")) then
			sec = "'"..sec.."'"
		end
		tab = 10-string.len(sec)/8
		for i=1,tab do
			sec = sec .. "\t"
		end
		if (m_class) then
			write_file("%s => '%s',",sec,m_class)
		end
	end
	--[[
	for sec,ct in pairs(se_smart_cover.registered_smartcovers) do
		m_class = "se_smart_cover"
		if (string.find(sec,"%.") or string.find(sec,"-")) then
			sec = "'"..sec.."'"
		end
		tab = 10-string.len(sec)/8
		for i=1,tab do
			sec = sec .. "\t"
		end
		if (m_class) then
			write_file("%s => '%s',",sec,m_class)
		end
	end
	--]]
	return "section_to_class:= all registred items printed to section_to_class.txt"
end
